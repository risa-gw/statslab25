---
title: "SOC-GA 2332 Intro to Stats Lab 13"
author: "Risa Gelles-Watnick"
date: "11/26/2025"
output:
  pdf_document
urlcolor: blue
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = F, message = F)

## import packages
pacman::p_load(
  tidyverse,
  data.table,
  stargazer,
  MatchIt, 
  PSweight,
  AER, 
  ggpubr, 
  haven,
  naniar, # missing data 
  Amelia # multiple imputation
)

options(scipen = 999)
```

# Part 0: Logistics

* **Problem set 4** due on Dec. 5th, 11:59pm
    + Treat `numsibling` as fixed within household even though it doesn't make a ton of sense
* **Replication Part II** due Dec. 15th, 5:00pm (no extensions)
    + Grades for Part I coming shortly

## Replication project tips

* Knit consistently and frequently as you write code
    + If you do hit a knitting error:
        + Start commenting things out until you can get it to run and then work backwards 
        + Delete everything from your environment (broom) and run your code from the beginning 
* If you’re hitting space issues on your computer, feel free to use a smaller sample (ex. 1%)
* Papers should be formatted as clean, final projects
    + Code chunks not showing 
    + Text formatted correctly and consistently 
    + Figures and tables numbered & labelled, with all text clearly readable
    + Utilize the [template on GitHub](https://github.com/risa-gw/statslab25/blob/main/final_project/final_project_template.Rmd) or [RMarkdown cheatsheets](https://rmarkdown.rstudio.com/lesson-15.HTML)
* Read instructions completely and carefully
* Comment up your code (both for me and for your future self!)
* Get started early so you can take advantage of your resources (office hours, class, etc.)

# Part 1: Exploring data sample

* Today we are going to review a specific type of weighting, Inverse Probability of Treatment Weighting (IPTW). We will use the Early Childhood Longitudinal Study dataset. 

* We will examine the effect of going to a Catholic school (`catholic = 1`), as opposed to a public school (`catholic = 0`), on students' standardized math score (`c5r2mtsc_std`). The pre-treatment covariates are:  
    * `race_white`: Is the student white (1) or not (0)?  
    * `p5hmage`: Mother’s age  
    * `w3income`: Family income  
    * `p5numpla`: Number of places the student has lived for at least 4 months  
    * `w3momed_hsb`: Is the mother’s education level high-school or below (1) or some college or more (0)?  

```{r import data, warning=FALSE, message=FALSE}
## import data
ecls <- read.csv("data/ecls.csv")

## covariates variable name vector
ecls_cov <- c('race_white', 'p5hmage', 'w3income', 'p5numpla', 'w3momed_hsb')

## remove observations with NAs
ecls_nomiss <- ecls %>%  
  select(c5r2mtsc_std, catholic, all_of(ecls_cov)) %>%
  na.omit()
```

## Explore sample

* First let's see if there is any apparent difference in outcome by school type without controlling for any covariates 

```{r}
## check difference in mean outcomes by school type
ecls %>%
  group_by(catholic) %>%
  summarise(n_students = n(),
            mean_math = mean(c5r2mtsc_std),
            std_error_math = sd(c5r2mtsc_std) / sqrt(n_students))

## two Sample t-test: (H0: mean math scores do not differ by school types)
with(ecls, t.test(c5r2mtsc_std ~ catholic))
```
* *Question:* How would we interpret this t-test? 

* Now let's explore the relationship between school type and other covariates.

* *Question:* What is endogenous sampling? When selection into the treatment group is not random (i.e. varies by some other factor)

* To check if we might be endogenous sampling, we first examine the difference in means by treatment status for covariates.

```{r balance before matching, warning=FALSE}
## check difference in means for pre-treatment covariates by school types
## summarise group means for covariates
ecls %>%
  group_by(catholic) %>%
  select(one_of(ecls_cov)) %>%
  summarise_all(funs(mean(., na.rm = T)))

## Two sample t-test for every covariate
## lapply: a build-in loop that apply the t-test function along the name vector
lapply(ecls_cov, function(v){
  t.test(ecls[, v] ~ ecls[, 'catholic'])
})
```

* As we can see, the difference in mean for covariates are statistically significant.  

# Part 2: Propensity Score

* *Question:* What is Inverse Probability of Treatment Weighting (IPTW)? It's weighting the sample by the inverse probability of being selected into the treatment group, given a person's other characteristics.

* *Question:* Why might we use IPTW? Individuals who were assigned to the treatment group even though they were much more likely to be assigned to the control group are a rare, and valuable counterfactual, so we want to count them more. 

* To conduct IPTW, we usually use propensity scores.

* Propensity scores are a one-number summary of all the different covariates' values for each individual. In this case, we'll use them to represent the probability of being treated given a set of pre-treatment covariates. 
* In `R`, we can estimate propensity score given the covariates by fitting a logistic regression with the treatment status as the outcome and covariates as predictors. So basically we're trying to predict what each observation's probability of being treated is. 
  * We still leverage the strong ignorability assumption and correct specification assumption to derive an unbiased estimate of the true propensity score.
    + *Question:* What are these two assumptions? Strong ignorability: no unobserved confounders (i.e., no variables are affecting treatment assignment that we can't include in the propensity score model). Correct specification: we specify the correct formula for our propensity score model. 
    
    
* Now let's try to fit propensity scores to our data. In reality this is usually a much longer and more iterative process, but for this demonstration I've simplified it into fitting a simple logistic regression. There are also ML algorithms that will find the best propensity score formula for you (ex. using SuperLearner throught the`WeightIt` package).

```{r propensity score, warning=FALSE}
## rescale income
ecls <- ecls %>% mutate(w3income_1k = w3income/1000)

## fit a logistic regress to generate propensity score using covariates
m_ps <- glm(catholic ~ race_white + w3income_1k + p5hmage + p5numpla + w3momed_hsb,
            family = binomial(), data = ecls) 
summary(m_ps)

## use above model to generate propensity 
## (the probability of being treated given a set of pre-treatment covariates)
prs_df <- data.frame(pr_score = predict(m_ps, type = "response"),
                     catholic = m_ps$model$catholic)

## check the region of common support
## in every unit in the treatment, is there a control unit
prs_df %>% 
  ggplot(aes(x = pr_score, fill = as.factor(catholic))) + 
  geom_histogram(binwidth = 0.02, alpha = 0.5, position="identity") +
  ggtitle("Probability of Going to Catholic School") +
  xlab("Propensity Score") +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5)) +
  scale_fill_manual(name=" ", 
                    values = c("blue", "red"),
                    labels = c("Non-Catholic", "Catholic")) 
```

# Part 3: Inverse probability weighting

* Use propensity scores to weight units based on their probabilities of being treated. 
    * e(x) is the propensity score
    * $w_1$ is weights if the unit is treated
    * $w_0$ is weights if the unit is untreated
* There are several options that measure different quantities of interest
  * `IPW` measures ATE. $weight(w_1,w_0) = (\frac{1}{e(x)},\frac{1}{1-e(x)})$
    * The core of `IPW` is to create a weighted treatment group and a weighted control group whose covariates' distribution resembles the distribution of the whole sample
  * `treated` measures ATT. $weight(w_1,w_0) = (1,\frac{e(x)}{1-e(x)})$
    * The core of `treated` is to create only a weighted control group whose covariates' distribution resembles the distribution of the unweighted treatment group 
  * `overlap` measures ATO (Average Treatment on Overlap). $weight(w_1,w_0) = (1 - e(x),e(x))$
    * The core of `overlap` is to give more weights to the observations near the center of the propensity, or the units under "equipoise"
* You may check [this site](https://stats.stackexchange.com/questions/529602/which-one-of-these-methods-ate-att-ato-overlap-should-be-used-to-evaluate-a) for more detailed explanations    

```{r matching algorithm, warning=FALSE}

## matching algorithm
ps.formula <- catholic ~ race_white + p5hmage +
                  I(w3income / 10^3) + p5numpla + w3momed_hsb

bal.ipw <- SumStat(ps.formula = ps.formula, zname ="catholic",
weight = c("treated", "overlap", "IPW"), data = ecls_nomiss)

# check balance by weight type 
plot(bal.ipw)
```

* Estimate ATT, ATO, and ATE: 

```{r estimate ATE by weighting, warning=FALSE}

## average treatment effect among the treated population
att <- PSweight(ps.formula = ps.formula, yname = "c5r2mtsc_std", data = ecls_nomiss, family = "gaussian",
weight = "treated")

## average treatment effect among the overlap population
ato <- PSweight(ps.formula = ps.formula, yname = "c5r2mtsc_std", data = ecls_nomiss, family = "gaussian",
weight = "overlap")

## average treatment effect using IPW
ate <- PSweight(ps.formula = ps.formula, yname = "c5r2mtsc_std", data = ecls_nomiss, family = "gaussian",
weight = "IPW")

## check results
summary(att)
summary(ate)
```

* *Question:* Why is ATE and ATT different? Looking at different groups. ATE changes both treatment and control group to make covariates equivalent whereas ATT makes control group covariates mimic treatment group without changing the treatment group.

# Exercise

Instead of removing observations with NAs, use one of the missing data strategies we covered in previous labs (see Lab 7). Then, run a regression to see whether school type affects math score. Do you get the same results as when you use IPTW? Why or why not?

```{r}
# checking missingness
gg_miss_var(ecls)
```

```{r}
# running multiple imputation 
a.out <- ecls %>% 
  select(catholic, c5r2mtsc_std, race_white, p5hmage, w3income, p5numpla, w3momed_hsb) %>% # selecting only variables we're using for regression
  amelia(., # telling amelia to use every variable in our dataset for imputation
         m = 5 # number of times to impute/number of datasets to create
         )
```
```{r}
# setting seed since multiple imputation involves randomness
set.seed(3636)

# running our regression model with each data set
mult_imp <- with(
  a.out,
  lm(c5r2mtsc_std ~ catholic + race_white + p5hmage +
                  I(w3income / 10^3) + p5numpla + w3momed_hsb)
)

# combining results
mar_mi <- mi.combine(mult_imp, conf.int = TRUE)

# showing results
mar_mi
```

We don't get the exact same results, but it's in the same direction and not statistically significant. We don't get exactly the same results because we haven't done away with the base issue, which is that some people are more likely to select into the treatment group than others. 

```{r}
## check difference in means for pre-treatment covariates by school types
## summarise group means for covariates
a.out[[1]]$imp1 %>%
  as.tibble() %>% 
  group_by(catholic) %>%
  select(one_of(ecls_cov)) %>%
  summarise_all(funs(mean(., na.rm = T)))

## Two sample t-test for every covariate
## lapply: a build-in loop that apply the t-test function along the name vector
lapply(ecls_cov, function(v){
  t.test(ecls[, v] ~ ecls[, 'catholic'])
})
```

